<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="utf-8" />
    <title>BeReal Map Premium</title>
    <link rel="icon" href="data:,">
    <script src="https://unpkg.com/maplibre-gl@3.x/dist/maplibre-gl.js"></script>
    <link href="https://unpkg.com/maplibre-gl@3.x/dist/maplibre-gl.css" rel="stylesheet" />
    <link href="https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap" rel="stylesheet">
    <style>
        /* --- STYLES GÉNÉRAUX --- */
        body { 
            margin: 0; padding: 0; 
            font-family: 'Inter', sans-serif; 
            background: #000; 
            overflow: hidden;
        }

        #map { 
            position: absolute; top: 0; bottom: 0; width: 100%; 
            transition: transform 0.7s cubic-bezier(0.19, 1, 0.22, 1), filter 0.7s cubic-bezier(0.19, 1, 0.22, 1);
            will-change: transform, filter;
        }

        /* --- MODAL STRUCTURE --- */
        #bereal-modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            display: none; justify-content: center; align-items: center;
            z-index: 9999; 
            background: transparent;
        }

        .modal-content { 
            width: 90%; max-width: 420px; 
            position: relative; display: flex; flex-direction: column; align-items: center; 
            animation: modalScale 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.1);
        }

        @keyframes modalScale {
            from { transform: scale(0.9); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        /* --- PHOTO CONTAINER & ZOOM --- */
        .bereal-container {
            position: relative; width: 100%; aspect-ratio: 3/4;
            border-radius: 24px; overflow: hidden; background: #1c1c1e;
            box-shadow: 0 40px 100px rgba(0,0,0,0.9);
            border: 1px solid rgba(255,255,255,0.2);
            cursor: zoom-in;
            touch-action: none;
        }

        .bereal-container.zoomed { cursor: zoom-out; }

        .main-img { 
            width: 100%; height: 100%; object-fit: cover; pointer-events: none;
            transform-origin: center center;
            will-change: transform;
        } 

        .bereal-container.zoomed .mini-img-container {
            opacity: 0;
            transform: scale(0.85);
            pointer-events: none;
        }

        .bereal-container.zoomed .main-img { transform: scale(2); }

        .bereal-logo-overlay {
            position: absolute; bottom: 6px; left: 50%; transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.5); font-weight: 600; font-size: 18px; 
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
            letter-spacing: -0.5px; pointer-events: none;
        }

        /* --- MINIATURE --- */
        .mini-img-container {
            position: absolute; top: 14px; left: 14px; width: 30%; aspect-ratio: 3/4; 
            border-radius: 14px; z-index: 10; border: 2px solid #000; 
            overflow: hidden; cursor: grab; box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            transition: opacity 0.3s ease, transform 0.3s ease;
        }
        .mini-img { width: 100%; height: 100%; object-fit: cover; pointer-events: none; }

        .bereal-container, .mini-img-container, .main-img, .mini-img {
            user-select: none;
            -webkit-user-drag: none;
            -webkit-tap-highlight-color: transparent;
        }

        /* Modification pour corriger le bug Safari */
        .main-img, .mini-img { 
            width: 100% !important; 
            height: 100% !important; 
            object-fit: cover; 
            /* Ajout de ces lignes spécifiques pour Safari */
            position: absolute;
            top: 0;
            left: 0;
            transform: translateZ(0); /* Force l'accélération matérielle */
            -webkit-transform: translateZ(0); /* Force l'accélération matérielle */
            pointer-events: none;
        }

        /* On s'assure que les containers ont une position relative pour le position absolute des images */
        .bereal-container, .mini-img-container {
            position: relative;
            mask-image: radial-gradient(white, black);
            -webkit-mask-image: -webkit-radial-gradient(white, black); /* Force Safari à respecter le border-radius */
        }

        /* --- FOOTER & TEXT --- */
        .bereal-footer { 
            width: 100%; text-align: center; color: white; padding-top: 10px; 
            pointer-events: none; z-index: 10; opacity: 1 !important; 
        }
        .bereal-caption { 
            font-size: 12px; color: #ffffff; font-weight: 400; margin-bottom: 4px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5); -webkit-font-smoothing: antialiased;
        }    
        .bereal-metadata { font-size: 9px; color: rgba(255, 255, 255, 0.6); font-weight: 300; margin-bottom: 12px; }
        .bereal-username { font-size: 35px; font-weight: 700; text-transform: uppercase; line-height: 0.9; }

        /* --- NAVIGATION --- */
        .nav-arrow {
            position: absolute; top: 50%; transform: translateY(-110%);
            background: rgba(255, 255, 255, 0.15); border: none; color: white; 
            width: 50px; height: 50px; border-radius: 50%; cursor: pointer;
            display: flex; align-items: center; justify-content: center; z-index: 100;
            backdrop-filter: blur(15px);
        }
        .prev { left: -70px; } .next { right: -70px; }
        .nav-arrow svg { width: 28px; height: 28px; fill: none; stroke: currentColor; stroke-width: 2.5; }

        @media (max-width: 600px) {
            .nav-arrow { display: none !important; }
            .bereal-username { font-size: 38px; }
        }
    </style>
</head>

<body>

<div id="map"></div>

<div id="bereal-modal" onclick="closeModal()">
    <div class="modal-content" onclick="event.stopPropagation()">
        <button id="prevBtn" class="nav-arrow prev" onclick="prevPhoto()"><svg viewBox="0 0 24 24"><polyline points="15 18 9 12 15 6"></polyline></svg></button>
        <button id="nextBtn" class="nav-arrow next" onclick="nextPhoto()"><svg viewBox="0 0 24 24"><polyline points="9 18 15 12 9 6"></polyline></svg></button>

        <div class="bereal-container" id="photo-container">
            <img id="main-photo" src="" class="main-img">
            <div id="mini-img-box" class="mini-img-container">
                <img id="mini-photo" src="" class="mini-img">
            </div>
            <div class="bereal-logo-overlay">BeReal.</div>
        </div>
        
        <div class="bereal-footer">
            <div id="modal-caption" class="bereal-caption"></div>
            <div id="modal-metadata" class="bereal-metadata"></div>
            <div class="bereal-username">MAAAEL.QLLT</div>
        </div>
    </div>
</div>

<script>
    // --- CONFIGURATION & GLOBALES ---
    const FOLDER_ID = "AF9TaX9kF2Ph70UyFt19wuMJvqr2-pGvnrPTVROrjNoqlXt1pl";
    const miniBox = document.getElementById('mini-img-box');
    const container = document.getElementById('photo-container');
    const mainPhoto = document.getElementById('main-photo');
    const photoContainer = document.getElementById('photo-container');

    let currentPhotos = [], currentIndex = 0, isFlipped = false;
    let isDragging = false, dragStartX, dragStartY, hasDragged = false, justFinishedDrag = false;
    let isZooming = false, zoomScale = 1, zoomOriginX = 50, zoomOriginY = 50;
    let initialPinchDistance = 0, isPinching = false;

    // --- HAPTIC FEEDBACK ---
    // #region HAPTIC_FEEDBACK
    function vibrate(type) {
        if (!navigator.vibrate) return;
        
        switch(type) {
            case 'light':    // Petit clic sec (Flip, Navigation)
                navigator.vibrate(10);
                break;
            case 'medium':   // Snap de la miniature
                navigator.vibrate(20);
                break;
            case 'error':    // Si on arrive au bout de la liste
                navigator.vibrate([10, 50, 10]);
                break;
        }
    }

    // ///////////////////////////////////////////////////////////////////////////////
    // // DRAG & FLIP LOGIC (Miniature)
    // ///////////////////////////////////////////////////////////////////////////////
    // #region DRAG_FLIP
    function snapToCorner() {
        vibrate('medium');
        miniBox.style.transition = 'all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275)';
        const containerMidPoint = container.offsetWidth / 2;
        const miniBoxCenter = miniBox.offsetLeft + (miniBox.offsetWidth / 2);
        
        if (miniBoxCenter < containerMidPoint) {
            miniBox.style.left = '14px';
        } else {
            miniBox.style.left = (container.offsetWidth - miniBox.offsetWidth - 14) + 'px';
        }
        miniBox.style.top = '14px';
    }

    miniBox.addEventListener('mousedown', (e) => {
        isDragging = true;
        hasDragged = false;
        dragStartX = e.clientX - miniBox.offsetLeft;
        dragStartY = e.clientY - miniBox.offsetTop;
        miniBox.style.transition = 'none';
        e.preventDefault(); e.stopPropagation();
    });

    document.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        hasDragged = true;
        let newLeft = e.clientX - dragStartX;
        let newTop = e.clientY - dragStartY;
        newLeft = Math.max(10, Math.min(newLeft, container.offsetWidth - miniBox.offsetWidth - 10));
        newTop = Math.max(10, Math.min(newTop, container.offsetHeight - miniBox.offsetHeight - 10));
        miniBox.style.left = newLeft + 'px';
        miniBox.style.top = newTop + 'px';
    });

    document.addEventListener('mouseup', (e) => {
        if (!isDragging) return;
        isDragging = false;
        if (!hasDragged) {
            flipImages();
            e.stopPropagation();
        } else {
            justFinishedDrag = true;
            snapToCorner();
            e.stopPropagation();
            setTimeout(() => { justFinishedDrag = false; }, 500);
        }
    });

    function flipImages() {
        isFlipped = !isFlipped;
        vibrate('light'); 
        const p = currentPhotos[currentIndex];
        resetZoomState();
        document.getElementById('main-photo').src = isFlipped ? p.front : p.back;
        document.getElementById('mini-photo').src = isFlipped ? p.back : p.front;
    }
    // #endregion


    // ///////////////////////////////////////////////////////////////////////////////
    // // ZOOM & PAN LOGIC (Hold to Zoom + Drag to Pan)
    // ///////////////////////////////////////////////////////////////////////////////
    // #region ZOOM_LOGIC
    let translateX = 0, translateY = 0;
    let lastMouseX, lastMouseY;

    function startZoom(clientX, clientY) {
        if (isZooming) return;
        isZooming = true;
        
        const rect = photoContainer.getBoundingClientRect();
        
        // Calcul de l'origine en %
        zoomOriginX = ((clientX - rect.left) / rect.width) * 100;
        zoomOriginY = ((clientY - rect.top) / rect.height) * 100;
        
        mainPhoto.style.transformOrigin = `${zoomOriginX}% ${zoomOriginY}%`;
        
        lastMouseX = clientX;
        lastMouseY = clientY;
        translateX = 0;
        translateY = 0;
        
        zoomScale = 2.5;
        mainPhoto.style.transition = 'transform 0.25s ease-out';
        updateTransform();
        photoContainer.classList.add('zoomed');
    }

    function handlePan(clientX, clientY) {
        if (!isZooming || isPinching) return;

        const dx = clientX - lastMouseX;
        const dy = clientY - lastMouseY;
        
        // On ajuste la vitesse de déplacement selon le zoom
        translateX += dx / zoomScale;
        translateY += dy / zoomScale;

        // --- CALCUL DES LIMITES (ANTI-BORD-GRIS) ---
        // Le principe : plus l'origine est proche d'un bord, 
        // moins on peut bouger dans cette direction.
        
        const ratio = (zoomScale - 1) / zoomScale;
        const rect = photoContainer.getBoundingClientRect();

        // Limites horizontales
        const limitLeft = rect.width * ratio * (zoomOriginX / 100);
        const limitRight = rect.width * ratio * (1 - zoomOriginX / 100);
        
        // Limites verticales
        const limitTop = rect.height * ratio * (zoomOriginY / 100);
        const limitBottom = rect.height * ratio * (1 - zoomOriginY / 100);

        // Application des contraintes
        translateX = Math.max(-limitRight, Math.min(limitLeft, translateX));
        translateY = Math.max(-limitBottom, Math.min(limitTop, translateY));

        lastMouseX = clientX;
        lastMouseY = clientY;
        
        mainPhoto.style.transition = 'none';
        updateTransform();
    }

    function updateTransform() {
        mainPhoto.style.transform = `scale(${zoomScale}) translate(${translateX}px, ${translateY}px)`;
    }

    function endZoom() {
        if (!isZooming) return;
        
        justFinishedDrag = true; 
        isZooming = false;
        
        mainPhoto.style.transition = 'transform 0.3s ease-out';
        zoomScale = 1;
        translateX = 0;
        translateY = 0;
        
        updateTransform();
        photoContainer.classList.remove('zoomed');

        // On réinitialise l'origine au centre après l'animation de dézoom
        setTimeout(() => {
            mainPhoto.style.transformOrigin = 'center center';
            justFinishedDrag = false;
        }, 300);
    }

    function resetZoomState() {
        isZooming = false; isPinching = false; zoomScale = 1;
        translateX = 0; translateY = 0;
        mainPhoto.style.transform = 'scale(1) translate(0,0)';
        photoContainer.classList.remove('zoomed');
    }

    function getDistance(touches) {
        return Math.hypot(touches[0].clientX - touches[1].clientX, touches[0].clientY - touches[1].clientY);
    }

    // --- Events Souris ---
    photoContainer.addEventListener('mousedown', (e) => {
        if (e.target.closest('.mini-img-container')) return;
        startZoom(e.clientX, e.clientY);
    });

    document.addEventListener('mousemove', (e) => {
        if (isZooming) handlePan(e.clientX, e.clientY);
    });

    document.addEventListener('mouseup', endZoom);

    // --- Events Tactiles ---
    photoContainer.addEventListener('touchstart', (e) => {
        if (e.target.closest('.mini-img-container')) return;
        if (e.touches.length === 2) {
            isPinching = true;
            initialPinchDistance = getDistance(e.touches);
        } else if (e.touches.length === 1) {
            startZoom(e.touches[0].clientX, e.touches[0].clientY);
        }
    }, { passive: false });

    photoContainer.addEventListener('touchmove', (e) => {
        if (e.target.closest('.mini-img-container')) return;
        e.preventDefault(); // Empêche le scroll de la page pendant le zoom

        if (e.touches.length === 2 && isPinching) {
            const currentDistance = getDistance(e.touches);
            zoomScale = Math.max(1, Math.min(4, currentDistance / initialPinchDistance * 2));
            updateTransform();
        } else if (e.touches.length === 1 && isZooming) {
            handlePan(e.touches[0].clientX, e.touches[0].clientY);
        }
    }, { passive: false });

    photoContainer.addEventListener('touchend', (e) => {
        if (e.touches.length === 0) {
            isPinching = false;
            endZoom();
        }
    });
    // #endregion

    // ///////////////////////////////////////////////////////////////////////////////
    // // MAP & DATA LOGIC
    // ///////////////////////////////////////////////////////////////////////////////
    // #region MAP_AND_MODAL_CORE
    const map = new maplibregl.Map({
        container: 'map',
        style: 'https://api.maptiler.com/maps/dataviz-dark/style.json?key=iYlIQdqzuS2kKjZemTWi',
        center: [2.21, 46.22], zoom: 5.5, maxZoom: 15
    });

    map.on('load', () => {
        const layers = map.getStyle().layers;
        layers.forEach((layer) => {
            if (layer.type === 'symbol' && layer.layout && layer.layout['text-field']) {
                map.setLayoutProperty(layer.id, 'text-field', ['coalesce', ['get', 'name:fr'], ['get', 'name:latin'], ['get', 'name']]);
            }
        });
    });

    async function init() {
        try {
            const response = await fetch('memories.json');
            const data = await response.json();
            const features = data.filter(m => m.location && m.location.latitude).map(m => ({
                type: 'Feature',
                geometry: { type: 'Point', coordinates: [m.location.longitude, m.location.latitude] },
                properties: {
                    caption: m.caption || "",
                    front: `${FOLDER_ID}/Photos/post/${m.frontImage.path.split('/').pop()}`,
                    back: `${FOLDER_ID}/Photos/post/${m.backImage.path.split('/').pop()}`,
                    date: m.takenTime ? new Date(m.takenTime).toLocaleDateString('fr-FR', { day: 'numeric', month: 'long', year: 'numeric' }) : "",
                    time: m.takenTime ? new Date(m.takenTime).toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' }) : "",
                    rawDate: m.takenTime
                }
            }));

            map.on('load', () => {
                map.addSource('bereal-src', { type: 'geojson', data: { type: 'FeatureCollection', features }, cluster: true, clusterMaxZoom: 20, clusterRadius: 50 });                
                map.addLayer({ id: 'clusters', type: 'circle', source: 'bereal-src', filter: ['has', 'point_count'], paint: { 'circle-color': '#000', 'circle-radius': 22, 'circle-stroke-width': 2, 'circle-stroke-color': '#fff' } });
                map.addLayer({ id: 'cluster-count', type: 'symbol', source: 'bereal-src', filter: ['has', 'point_count'], layout: { 'text-field': '{point_count}', 'text-size': 14 }, paint: { 'text-color': '#fff' } });
                map.addLayer({ id: 'unclustered-point', type: 'circle', source: 'bereal-src', filter: ['!', ['has', 'point_count']], paint: { 'circle-color': '#fff', 'circle-radius': 8, 'circle-stroke-width': 2, 'circle-stroke-color': '#000' } });

                const clickFn = (e) => {
                    const features = map.queryRenderedFeatures(e.point, { layers: ['clusters'] });
                    if (features.length > 0) {
                        const feature = features[0];
                        const source = map.getSource('bereal-src');
                        source.getClusterExpansionZoom(feature.properties.cluster_id, (err, expansionZoom) => {
                            source.getClusterLeaves(feature.properties.cluster_id, Infinity, 0, (err, leaves) => {
                                if (map.getZoom() >= 14.5 || expansionZoom > 15) {
                                    let photos = leaves.map(l => l.properties).sort((a, b) => new Date(b.rawDate) - new Date(a.rawDate));
                                    startModal(photos);
                                } else {
                                    map.easeTo({ center: feature.geometry.coordinates, zoom: expansionZoom });
                                }
                            });
                        });
                    } else {
                        const p = map.queryRenderedFeatures(e.point, { layers: ['unclustered-point'] });
                        if (p.length > 0) startModal([p[0].properties]);
                    }
                };
                map.on('click', 'clusters', clickFn); map.on('click', 'unclustered-point', clickFn);
            });
        } catch (e) { console.error(e); }
    }

    function startModal(photos) {
        currentPhotos = photos; currentIndex = 0;
        updateModalContent();
        document.getElementById('bereal-modal').style.display = 'flex';
        const mapEl = document.getElementById('map');
        mapEl.style.transform = 'scale(1.1)';
        mapEl.style.filter = 'blur(5px) saturate(160%) brightness(0.5)';
    }

    function updateModalContent() {
        const p = currentPhotos[currentIndex];
        isFlipped = false;
        resetZoomState();
        
        document.getElementById('main-photo').src = p.back;
        document.getElementById('mini-photo').src = p.front;
        document.getElementById('modal-caption').innerText = p.caption || "allez le rugby";
        document.getElementById('modal-metadata').innerText = `${p.date} • ${p.time}`;
        
        miniBox.style.transition = 'none';
        miniBox.style.left = '14px';
        miniBox.style.top = '14px';
        
        const multi = currentPhotos.length > 1;
        document.getElementById('prevBtn').style.display = (multi && currentIndex > 0) ? 'flex' : 'none';
        document.getElementById('nextBtn').style.display = (multi && currentIndex < currentPhotos.length - 1) ? 'flex' : 'none';
    }

    function nextPhoto() { if(currentIndex < currentPhotos.length - 1) { currentIndex++; vibrate('light'); updateModalContent(); } }
    function prevPhoto() { if(currentIndex > 0) { currentIndex--; vibrate('light'); updateModalContent(); } }
    
    function closeModal() { 
        // Si on est en train de glisser la miniature OU si on vient de finir un zoom/pan
        // on ne ferme pas le modal.
        if (isDragging || justFinishedDrag || isZooming) return;
        
        document.getElementById('bereal-modal').style.display = 'none'; 
        const mapEl = document.getElementById('map');
        mapEl.style.transform = 'scale(1)';
        mapEl.style.filter = 'none';
    }
    // #endregion

    init();
</script>
</body>
</html>